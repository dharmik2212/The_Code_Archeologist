import { HfInference } from '@huggingface/inference';
import * as vscode from 'vscode';

import { BlameResult, CodeChunk } from '../types';
import type { CommitContext } from '../git/commits';

function formatCommitContext(commitContext: Map<string, CommitContext>): string {
  if (commitContext.size === 0) return '(none)';
  const lines: string[] = [];
  for (const ctx of commitContext.values()) {
    const sha8 = ctx.commit.slice(0, 8);
    lines.push(`${sha8} | ${ctx.author ?? 'unknown'} | ${ctx.authorTime ?? ''} | ${ctx.subject ?? ''}`.trim());
  }
  return lines.join('\n');
}

function formatCommitPatches(commitContext: Map<string, CommitContext>): string {
  const blocks: string[] = [];
  for (const ctx of commitContext.values()) {
    if (!ctx.patches || ctx.patches.length === 0) continue;
    const sha8 = ctx.commit.slice(0, 8);
    for (const p of ctx.patches) {
      blocks.push([
        `COMMIT ${sha8} FILE ${p.file}`,
        p.patch
      ].join('\n'));
    }
  }
  return blocks.length ? blocks.join('\n\n---\n\n') : '(none)';
}

function formatContext(chunks: CodeChunk[], blame: BlameResult[]): string {
  const blameByKey = new Map<string, BlameResult>();
  for (const b of blame) {
    blameByKey.set(`${b.uri.toString()}|${b.startLine0}|${b.endLine0}`, b);
  }

  const sections: string[] = [];

  for (const chunk of chunks) {
    const key = `${chunk.uri.toString()}|${chunk.startLine0}|${chunk.endLine0}`;
    const b = blameByKey.get(key);

    const header = `FILE: ${chunk.uri.fsPath}\nLINES: ${chunk.startLine0 + 1}-${chunk.endLine0 + 1}`;

    const blameLines = b?.lines?.length
      ? b.lines
          .slice(0, 120)
          .map((l) => `${l.line1}: ${l.author ?? 'unknown'} (${l.commit.slice(0, 8)})`)
          .join('\n')
      : b?.error
        ? `BLAME_ERROR: ${b.error}`
        : 'BLAME: (none)';

    sections.push([header, 'BLAME:', blameLines, 'CODE:', chunk.text].join('\n'));
  }

  return sections.join('\n\n---\n\n');
}

export async function generateAnswer(opts: {
  token: string;
  question: string;
  chunks: CodeChunk[];
  blame: BlameResult[];
  commitContext: Map<string, CommitContext>;
  cancellationToken?: vscode.CancellationToken;
}): Promise<string> {
  const cfg = vscode.workspace.getConfiguration('codeArcheologist');
  const model = cfg.get<string>('answerModel', 'meta-llama/Llama-3.1-8B-Instruct');

  const hf = new HfInference(opts.token);

  const context = formatContext(opts.chunks, opts.blame);
  const commits = formatCommitContext(opts.commitContext);
  const commitPatches = formatCommitPatches(opts.commitContext);

  const prompt = [
    'You are a VS Code extension called Code Archeologist.',
    'You answer questions about the provided code snippets from the user\'s workspace.',
    '',
    'You MUST use the BLAME and COMMIT CONTEXT sections to:',
    '- Identify who wrote the relevant lines (author attribution).',
    '- Explain what might break if those lines change (impact analysis).',
    '- Use COMMIT DIFF SNIPPETS to infer intent (why it was changed) and risk (what assumptions exist).',
    '',
    'Rules:',
    '- Only use the provided CODE/BLAME/COMMIT context. If you are unsure, say what you are missing.',
    '- When discussing who wrote it, cite FILE + line range(s) and the author name from BLAME.',
    '- When discussing impact, be concrete: name the likely contract/API being changed, what callers depend on, and what runtime/compile/test failures could occur.',
    '- If you cannot see callers/usages in the provided context, say that explicitly and give verification steps.',
    '- Avoid absolute claims; present risks as likely/possible and include how to validate them.',
    '',
    'Output format:',
    '1) Who wrote it (with file + line ranges + commits)',
    '2) Why it exists (use commit subjects if relevant)',
    '3) What might break if changed (ranked risks + how to verify)',
    '4) Answer (direct response to the question)',
    '',
    'USER QUESTION:',
    opts.question,
    '',
    'COMMIT CONTEXT (sha8 | author | date | subject):',
    commits,
    '',
    'COMMIT DIFF SNIPPETS (may be truncated):',
    commitPatches,
    '',
    'CODEBASE CONTEXT:',
    context
  ].join('\n');

  try {
    const res = await hf.textGeneration(
      {
        model,
        inputs: prompt,
        parameters: {
          max_new_tokens: 900,
          temperature: 0.2,
          return_full_text: false
        }
      },
      {
        signal: opts.cancellationToken ? (opts.cancellationToken as any) : undefined
      }
    );

    const text = (res as any)?.generated_text ?? '';
    return text.trim() || 'No answer was generated by the model.';
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    if (message.includes('fetch') || message.includes('network')) {
      throw new Error(`Network error calling HuggingFace API: ${message}. Check your internet connection and HF_TOKEN.`);
    }
    if (message.includes('401') || message.includes('Unauthorized')) {
      throw new Error('Invalid HuggingFace token. Run: Code Archeologist: Set Hugging Face Token');
    }
    if (message.includes('429') || message.includes('Rate limit')) {
      throw new Error('HuggingFace rate limit exceeded. Please wait a moment and try again.');
    }
    throw new Error(`Failed to generate answer: ${message}`);
  }
}
